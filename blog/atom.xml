<feed xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns="http://www.w3.org/2005/Atom">
      <title>Lagom Blog</title>
      <link rel="alternate" type="text/html" href="https://www.lagomframework.com/blog"/>
      <link rel="self" type="application/atom+xml" href="https://www.lagomframework.com/blog/atom.xml"/>
      <id>https://www.lagomframework.com/blog</id>
      <rights>Copyright 2017, Lightbend</rights>
      <updated>2017-04-28T10:00:00.000+10:00</updated>
      <dc:creator>Lightbend</dc:creator>
      <dc:date>2017-04-28T10:00:00.000+10:00</dc:date>
      <dc:language>en</dc:language>
      <dc:rights>Copyright 2017, Lightbend</dc:rights>
      <entry>
          <title>Lagom 1.3.3 is released!</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-3-3.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-3-3.html</id>
          <updated>2017-04-28T10:00:00.000+10:00</updated>
          <published>2017-04-28T10:00:00.000+10:00</published>
          <content type="html"><![CDATA[<p>The Lagom team has released Lagom 1.3.3. This release is primarily a bugfix release, fixing issues related to Cassandra and Kafka.</p>
<h2><a href="#updating" name="updating">Updating</a></h2>
<p>To update an sbt project, change the version of <code>lagom-sbt-plugin</code> in your <code>project/plugins.sbt</code> file.</p>
<p>To update a Maven project, change the <code>lagom.version</code> property in your top-level <code>pom.xml</code>.</p>
<h2><a href="#migration-notes" name="migration-notes">Migration notes</a></h2>
<p>Binding multiple Lagom service descriptors in one Lagom service has been deprecated in this release. Although your Lagom services should continue to function with no changes, we recommend you update your application to fix any deprecation warnings that may have been introduced.</p>
<p>If you are currently binding multiple Lagom service descriptors in one Lagom service, you should combine these into one. The reason for this change is that we found most microservice deployment platforms simply don&rsquo;t support having multiple names for the one service, hence a service that serves multiple service descriptors, each with their own name, would not be compatible with those environments.</p>
<p>Consequently, we have deprecated the methods for binding multiple service descriptors. To migrate, follow the instructions specific to your language:</p>
<h3><a href="#java" name="java">Java</a></h3>
<p>Instead of:</p>
<pre class="prettyprint"><code class="language-java">bindServices(serviceBinding(MyService.class, MyServiceImpl.class));
</code></pre>
<p>Use:</p>
<pre class="prettyprint"><code class="language-java">bindService(MyService.class, MyServiceImpl.class);
</code></pre>
<h3><a href="#scala" name="scala">Scala</a></h3>
<p>Instead of:</p>
<pre class="prettyprint"><code class="language-scala">lazy val lagomServer = LagomServer.forServices(bindService[MyService].to(wire[MyServiceImpl]))
</code></pre>
<p>Use:</p>
<pre class="prettyprint"><code class="language-scala">lazy val lagomServer = serverFor[MyService](wire[MyServiceImpl])
</code></pre>
<h2><a href="#change-log" name="change-log">Change log</a></h2>
<p>See the <a href="https://www.lagomframework.com/changelog.html">change log</a> for more details on exactly what has been fixed in each release.</p>]]></content>
          <dc:date>2017-04-28T10:00:00.000+10:00</dc:date>
        </entry><entry>
          <title>Lagom 1.3.2 is released!</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-3-2.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>Tim Moore</name>
            <uri>https://github.com/TimMoore</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-3-2.html</id>
          <updated>2017-04-19T10:00:00.000+10:00</updated>
          <published>2017-04-19T10:00:00.000+10:00</published>
          <content type="html"><![CDATA[<p>The Lagom team has just released Lagom 1.3.2. This release includes bug fixes and other minor changes, a dependency management improvement for Maven users, and deprecates a feature that proved to be confusing.</p>
<h2><a href="#updating" name="updating">Updating</a></h2>
<p>To update an sbt project, change the version of <code>lagom-sbt-plugin</code> in your <code>project/plugins.sbt</code> file.</p>
<p>To update a Maven project, change the <code>lagom.version</code> property in your top-level <code>pom.xml</code>.</p>
<p>If you are using Lagom&rsquo;s support for Maven builds or Cassandra persistence, there are some other (optional) steps you should follow below.</p>
<h2><a href="#dependency-management-in-maven" name="dependency-management-in-maven">Dependency management in Maven</a></h2>
<p>Lagom brings together several rich libraries and frameworks and this means many transitive dependencies. Managing these dependencies and avoiding conflicts can be tricky.</p>
<p>Lagom 1.3.2 introduces a new POM artifact that you can use in your top-level <code>pom.xml</code> in order to control the versions of transitive dependencies brought in by both Lagom and other libraries you depend on. This relies on Maven&rsquo;s support for <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies">importing dependencies</a> in the <code>dependencyManagement</code> section of your POM.</p>
<p>To use this, follow these steps:</p>
<ol>
  <li>Open the top-level <code>pom.xml</code> for each of your Maven Lagom projects in an editor</li>
  <li>Add an import-scope dependency for <code>lagom-maven-dependencies</code> to the <code>dependencyManagement</code> section, within the nested <code>dependencies</code> element:
    <pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.lightbend.lagom&lt;/groupId&gt;
    &lt;artifactId&gt;lagom-maven-dependencies&lt;/artifactId&gt;
    &lt;version&gt;${lagom.version}&lt;/version&gt;
    &lt;scope&gt;import&lt;/scope&gt;
    &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;
</code></pre>
  </li>
  <li>
  <p>Remove any other previous entries for dependencies with the <code>com.lightbend.lagom</code> <code>groupId</code>, and the entries for <code>akka-actor_2.11</code> and <code>akka-stream_2.11</code>.</p></li>
</ol>
<p>This ensures that the resolved versions of all artifacts that Lagom depends on, directly or indirectly, match the versions that Lagom was tested with.</p>
<p>New projects built from the Lagom Maven archetype include this configuration by default. You might want to <a href="https://www.lagomframework.com/documentation/1.3.x/java/GettingStartedMaven.html">create a new project from the archetype</a> to compare the generated <code>pom.xml</code> with your existing projects.</p>
<p>This <code>dependencyManagement</code> feature of Maven has no exact equivalent in sbt. We have found sbt&rsquo;s default conflict resolution algorithm to be less surprising than Maven&rsquo;s, and has fewer problems in practice, but we are looking into possibilities to improve this further in sbt as well.</p>
<h2>Deprecated: default Cassandra keyspaces</h2>
<p>Lagom&rsquo;s persistence needs a few tables to store its data. These tables are stored in Cassandra keyspaces. Each service should use a unique keyspace name so that the tables of different services do not conflict with each other. You need to configure the keyspaces that are used for these tables in the <code>application.conf</code> file of each of your service implementation projects. For example:</p>
<pre class="prettyprint"><code>my-service.cassandra.keyspace = my_service

cassandra-journal.keyspace = ${my-service.cassandra.keyspace}
cassandra-snapshot-store.keyspace = ${my-service.cassandra.keyspace}
lagom.persistence.read-side.cassandra.keyspace = ${my-service.cassandra.keyspace}
</code></pre>
<p>Previous versions of Lagom automatically calculated a default Cassandra keyspace for each service, based on the name of the service project, and injected this keyspace configuration in development mode. When running in production, these calculated keyspaces were not used, resulting in multiple services sharing the same keyspaces by default if these properties were not configured in <code>application.conf</code>.</p>
<p>Because of this unexpected inconsistency between the development and production environments, Lagom 1.3.2 deprecates the development environment behavior and prints a warning if these properties are not defined in a service that uses Cassandra persistence. The <code>cassandraKeyspace</code> parameter for the Lagom Maven plugin and <code>lagomCassandraKeyspace</code> setting for the Lagom sbt plugin are also deprecated, as it was not clear to everyone that these settings only affect the development environment, and are not used when keyspaces are configured in <code>application.conf</code>.</p>
<p>New projects built from the Lagom Maven archetype or using <code>sbt new</code> and Lagom&rsquo;s g8 templates (either <a href="https://github.com/lagom/lagom-java.g8">java</a> or <a href="https://github.com/lagom/lagom-scala.g8">scala</a> ) include this configuration by default, using the name of the project it prompts you for to assign a default keyspace to the example persistent service implementation. You can change this default as required, and should be sure to configure unique keyspaces for additional service implementations as you create them.</p>
<p>In Lagom 1.4, services that use Cassandra persistence will fail on startup when these properties are not defined.</p>
<p>See <a href="https://www.lagomframework.com/documentation/1.3.x/java/PersistentEntityCassandra.html#Configuration">Storing Persistent Entities in Cassandra</a> for configuration details and <a href="https://github.com/lagom/lagom/issues/578">issue #578</a> for more background.</p>
<h2><a href="#change-log" name="change-log">Change log</a></h2>
<p>See the <a href="https://www.lagomframework.com/changelog.html">change log</a> for more details on exactly what has been fixed in each release.</p>]]></content>
          <dc:date>2017-04-19T10:00:00.000+10:00</dc:date>
        </entry><entry>
          <title>Lagom 1.3.1 and 1.2.3 are released!</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-3-1-and-1-2-3.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>Tim Moore</name>
            <uri>https://github.com/TimMoore</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-3-1-and-1-2-3.html</id>
          <updated>2017-03-06T11:00:00.000+11:00</updated>
          <published>2017-03-06T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team has just released Lagom 1.3.1, with a few small, but important, bug fixes.</p>
<p>For those who have not made the jump to Lagom 1.3 yet, we also released 1.2.3 with backported bug fixes for issues that affect the 1.2 series.</p>
<p>To update an sbt project, change the version of <code>lagom-sbt-plugin</code> in your <code>project/plugins.sbt</code> file.</p>
<p>To update a Maven project, change the <code>lagom.version</code> property in your top-level <code>pom.xml</code>.</p>
<p>See the <a href="https://www.lagomframework.com/changelog.html">change log</a> for more details on exactly what has been fixed in each release.</p>]]></content>
          <dc:date>2017-03-06T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.3.0 is released!</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-3.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-3.html</id>
          <updated>2017-02-23T11:00:00.000+11:00</updated>
          <published>2017-02-23T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>Lagom 1.3.0 has been released! This much anticipated release includes the new Lagom Scala API, an issue voted on by over <a href="https://github.com/lagom/lagom/issues/1">400 people</a>. In addition, it also includes JPA support, allowing developers familiar with a more traditional Java stack to ease their way into Lagom without having to relearn everything at once.</p>
<h2><a href="#scala-api" name="scala-api">Scala API</a></h2>
<p>The new Scala API provides feature parity with the Java API, meaning that both APIs are now first class citizens in the Lagom ecosystem. We are committed to providing a great microservices development framework for both languages, and this release is making good on that promise for Scala. Going forward with new features, in Lagom, the definition of done in Lagom is defined to mean that a feature is not complete unless it provides API and documentation parity for both the Scala and Java APIs.</p>
<p>Having said that the Scala and Java APIs have feature parity, this does not mean that the APIs and approaches used are identical. Our approach to creating Scala APIs in Lagom has been to provide Scala developers with more type safety and less reliance on reflection than the Java API uses. Some major differences therefore between the Scala API and Java API are:</p>
<ul>
  <li>Use of type class based serialization, based on play-json, rather than using Jackson&rsquo;s reflection based databind API.</li>
  <li>Use of compile time wired dependency injection, utilizing the cake pattern and <a href="https://github.com/adamw/macwire">MacWire</a>, rather than using Guice.</li>
  <li>Use of macros to implement service clients and to wire service implementations, rather than dynamic proxies and reflection.</li>
</ul>
<p>We feel that developers that have already bought into the increased type safety that using Scala can give will appreciate this difference in approach, and so it makes sense to differ the Scala and Java APIs in this way.</p>
<p>To get started with the Lagom Scala API, read our <a href="https://www.lagomframework.com/documentation/1.3.x/scala/Installation.html">getting started guide</a>.</p>
<h2><a href="#jpa-support" name="jpa-support">JPA support</a></h2>
<p>Lagom&rsquo;s new JPA support includes two important features:</p>
<ul>
  <li>Managed execution of interactions with a JPA entity manager.</li>
  <li>Read side processor support with automatic offset management.</li>
</ul>
<p>In a non blocking framework, the use of blocking APIs, such as JPA, can be very dangerous. A few database queries can easily hold up the entire application, and the interaction between thread pools and connection pools is prone to deadlocks. It&rsquo;s therefore important that any blocking operations are carefully managed, ensuring that the thread pools used by database operations are not allowed to block asynchronous IO operations from proceeding.</p>
<p>Lagom takes responsibility of this management, by providing APIs that allow developers to safely use blocking entity manager operations without interfering with asynchronous IO threads. This is provided through the use of a <a href="https://www.lagomframework.com/documentation/1.3.x/java/api/index.html?com/lightbend/lagom/javadsl/persistence/jpa/JpaSession.html"><code>JpaSession</code></a> abstraction.</p>
<p>Lagom also offers specific support for JPA read-side processors, allowing users to seamlessly implement read-sides that focus on the database access logic, rather than having to concentrate on the mechanics of read-sides and offset tracking. For more information, read the <a href="https://www.lagomframework.com/documentation/1.3.x/java/ReadSideJPA.html">JPA read-side documentation</a></p>
<h2><a href="#getting-started" name="getting-started">Getting started</a></h2>
<p>Lagom is a framework which is designed to ease developers into writing reactive microservices, providing guide rails to ensure that they write services that are resilient and scalable. For this reason, the getting started experience in Lagom is very important, and that&rsquo;s why we&rsquo;ve started investing a lot of effort into the usability of our getting started guides. This effort is on going, but Lagom 1.3 comes with the first glimpse of this work, with a reworked downloads page on the website (now renamed to <a href="https://www.lagomframework.com/get-started.html">Get started</a>), and an improved getting started section in our documentation.</p>
<p>As we continue this effort, you should see an overhaul of the journey we take users on in our documentation, from design and development through to production.</p>
<h2><a href="#improved-test-apis" name="improved-test-apis">Improved test APIs</a></h2>
<p>Another place that we&rsquo;ve put effort into is providing how value test APIs to facilitate in testing Lagom services. In 1.3, a message broker testkit has been introduced, to allow testing of message broker integration. You can read about these APIs for <a href="https://www.lagomframework.com/documentation/1.3.x/java/MessageBrokerTesting.html">Java</a> and <a href="https://www.lagomframework.com/documentation/1.3.x/scala/MessageBrokerTesting.html">Scala</a>.</p>
<h2><a href="#migration" name="migration">Migration</a></h2>
<p>Lagom 1.3 is almost entirely binary and source compatible with 1.2 - we have taken great care to ensure that we only break compatibility when all other options have been exhausted. A short migration guide for upgrading from Lagom 1.2 can be found <a href="https://www.lagomframework.com/documentation/1.3.x/java/Migration13.html">here</a>. In addition, we&rsquo;ve also provided a short guide for the steps necessary for migrating from using the Java API to using the Scala API, which can be found <a href="https://www.lagomframework.com/documentation/1.3.x/scala/Migration13.html">here</a>.</p>]]></content>
          <dc:date>2017-02-23T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom Scala API release candidate 2</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-3-RC2.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-3-RC2.html</id>
          <updated>2017-02-17T11:00:00.000+11:00</updated>
          <published>2017-02-17T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>We&rsquo;re happy to announce that Lagom 1.3.0-RC2 has been released!</p>
<p>This release candidate includes the new Lagom Scala API, fully documented and with feature parity with the Java API.</p>
<h2><a href="#scala-api-design-philosophy" name="scala-api-design-philosophy">Scala API design philosophy</a></h2>
<p>In Lagom, we want both the Java API and the Scala API to be first class citizens, not one API built on the other, or one API augmented so that it works with the other language. For this reason, we have created two completely separate APIs, these APIs are provided by completely separate libraries, and typically will not be on the classpath at the same time. The namespaces selected for these APIs follow the convention introduced by Akka streams, namely that the Java API has a package name of <code>javadsl</code>, while the Scala API has a package name of <code>scaladsl</code>.</p>
<p>In general, when creating the Scala API, we have typically started with the Java API, and then worked from there to make it more idiomatic for Scala use. Some of the major differences from the Java API include:</p>
<ul>
  <li>Compile time dependency injection. Lagom&rsquo;s Java API builds on Play&rsquo;s Guice support. Lagom&rsquo;s Scala API however uses a lightweight form of the cake pattern to wire dependencies together. This API is designed to work well with <a href="https://github.com/adamw/macwire">Macwire</a>, though Macwire is not required to use it.</li>
  <li>Stronger typed APIs where Scala allows, particularly in the persistent entity API.</li>
  <li>Use of type classes to provide serializers and path parameter extractors, rather than using reflection.</li>
  <li>Use of <a href="https://playframework.com/documentation/2.5.x/ScalaJson">play-json</a> for JSON serialization support.</li>
  <li>Use of macros to implement service clients, rather than dynamic proxies.</li>
</ul>
<h2><a href="#other-features" name="other-features">Other features</a></h2>
<p>Other new features in this release include:</p>
<ul>
  <li>JPA support, including JPA read side processor support.</li>
  <li>New test APIs for testing message broker integration.</li>
  <li>Activator is now deprecated, in favour of the new Giter8 support in sbt 0.13.13.</li>
</ul>
<h2><a href="#sample-apps" name="sample-apps">Sample apps</a></h2>
<p>The Lagom team has been working on an auction system that demonstrates many of the features of Lagom. You can get the Java version <a href="https://github.com/lagom/online-auction-java">here</a> and the Scala version <a href="https://github.com/lagom/online-auction-scala">here</a>. Please be aware that these apps are still a work in progress.</p>
<h2><a href="#migration" name="migration">Migration</a></h2>
<p>There are no major API changes from 1.3.0-RC1, this release primarily just contains bug fixes.</p>]]></content>
          <dc:date>2017-02-17T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom Scala API release candidate</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-3-RC1.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-3-RC1.html</id>
          <updated>2017-01-24T11:00:00.000+11:00</updated>
          <published>2017-01-24T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>We&rsquo;re happy to announce that Lagom 1.3.0-RC1 has been released!</p>
<p>This release candidate includes the new Lagom Scala API, fully documented and with feature parity with the Java API.</p>
<h2><a href="#scala-api-design-philosophy" name="scala-api-design-philosophy">Scala API design philosophy</a></h2>
<p>In Lagom, we want both the Java API and the Scala API to be first class citizens, not one API built on the other, or one API augmented so that it works with the other language. For this reason, we have created two completely separate APIs, these APIs are provided by completely separate libraries, and typically will not be on the classpath at the same time. The namespaces selected for these APIs follow the convention introduced by Akka streams, namely that the Java API has a package name of <code>javadsl</code>, while the Scala API has a package name of <code>scaladsl</code>.</p>
<p>In general, when creating the Scala API, we have typically started with the Java API, and then worked from there to make it more idiomatic for Scala use. Some of the major differences from the Java API include:</p>
<ul>
  <li>Compile time dependency injection. Lagom&rsquo;s Java API builds on Play&rsquo;s Guice support. Lagom&rsquo;s Scala API however uses a lightweight form of the cake pattern to wire dependencies together. This API is designed to work well with <a href="https://github.com/adamw/macwire">Macwire</a>, though Macwire is not required to use it.</li>
  <li>Stronger typed APIs where Scala allows, particularly in the persistent entity API.</li>
  <li>Use of type classes to provide serializers and path parameter extractors, rather than using reflection.</li>
  <li>Use of <a href="https://playframework.com/documentation/2.5.x/ScalaJson">play-json</a> for JSON serialization support.</li>
  <li>Use of macros to implement service clients, rather than dynamic proxies.</li>
</ul>
<h2><a href="#other-features" name="other-features">Other features</a></h2>
<p>Other new features in this release include:</p>
<ul>
  <li>JPA support, including JPA read side processor support.</li>
  <li>New test APIs for testing message broker integration.</li>
  <li>Activator is now deprecated, in favour of the new Giter8 support in sbt 0.13.13.</li>
</ul>
<h2><a href="#sample-apps" name="sample-apps">Sample apps</a></h2>
<p>The Lagom team has been working on an auction system that demonstrates many of the features of Lagom. You can get the Java version <a href="https://github.com/lagom/online-auction-java">here</a> and the Scala version <a href="https://github.com/lagom/online-auction-scala">here</a>. Please be aware that these apps are still a work in progress.</p>
<h2><a href="#migration" name="migration">Migration</a></h2>
<p>If you were using the Scala API in the M1 release of Lagom 1.3.0, there are some significant changes to the API that have occurred:</p>
<ul>
  <li>Rework of Akka serializers, including removal of <code>Jsonable</code>, and programatic registration of the serializer registry rather than in the configuration file. See <a href="https://github.com/lagom/lagom/pull/399">this pull request</a> for a summary of changes.</li>
  <li>A major type bug has been fixed in persistent entities. As a result of the fix, <code>Persist</code> no longer has a type parameter, and <code>afterPersist</code> callbacks have been split into their own method parameter groups.</li>
  <li><code>LagomDevModeComponents</code> has been moved to the <code>com.lightbend.lagom.scaladsl.devmode</code> package.</li>
  <li>Streamed service calls are now required to declare their <code>Source</code> message types to materialize to <code>NotUsed</code>, where before they were required to materialize to an unbound wildcard.</li>
</ul>]]></content>
          <dc:date>2017-01-24T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.2.2 is ready!</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-2-2.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>Ignasi Marimon-Clos</name>
            <uri>https://github.com/ignasi35</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-2-2.html</id>
          <updated>2017-01-12T11:00:00.000+11:00</updated>
          <published>2017-01-12T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team is proud to announce the availability of the 1.2.2 version. This release provides a bugfix affecting maven users that opted for JDBC persistence instead of Cassandra persistence.</p>
<p>Thanks @dsugden for reporting the issue and helping fix it.</p>
<hr/>
<p>Lagom 1.3 is almost here with a ton of <a href="https://github.com/lagom/lagom/milestone/4">new features</a>, so continue <a href="https://www.lagomframework.com/get-involved.html">shaping</a> the future of Lagom.</p>]]></content>
          <dc:date>2017-01-12T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Introducing the Lagom Scala API</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-scala-api-preview.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/><category term="scala" scheme="https://www.lagomframework.com/blog/tags/scala.html"/>
          <author>
            <name>James Roper</name>
            <uri>https://github.com/jroper</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-scala-api-preview.html</id>
          <updated>2016-12-09T11:00:00.000+11:00</updated>
          <published>2016-12-09T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team are proud to announce the first milestone release of the Lagom Scala API, Lagom 1.3.0-M1! This release has been many months in the making, and we&rsquo;ve cut this milestone as a preview release in the hope that we can get some early feedback before we cut the final release.</p>
<h2><a href="#design-philosophy" name="design-philosophy">Design philosophy</a></h2>
<p>In Lagom, we want both the Java API and the Scala API to be first class citizens, not one API built on the other, or one API augmented so that it works with the other language. For this reason, we have created two completely separate APIs, these APIs are provided by completely separate libraries, and typically will not be on the classpath at the same time. The namespaces selected for these APIs follow the convention introduced by Akka streams, namely that the Java API has a package name of <code>javadsl</code>, while the Scala API has a package name of <code>scaladsl</code>.</p>
<p>In general, when creating the Scala API, we have typically started with the Java API, and then worked from there to make it more idiomatic for Scala use. Some of the major differences from the Java API include:</p>
<ul>
  <li>Compile time dependency injection. Lagom&rsquo;s Java API builds on Play&rsquo;s Guice support. Lagom&rsquo;s Scala API however uses a lightweight form of the cake pattern to wire dependencies together. This API is designed to work well with <a href="https://github.com/adamw/macwire">Macwire</a>, though Macwire is not required to use it.</li>
  <li>Stronger typed APIs where Scala allows, particularly in the persistent entity API.</li>
  <li>Use of type classes to provide serializers and path parameter extractors, rather than using reflection.</li>
  <li>Use of <a href="https://playframework.com/documentation/2.5.x/ScalaJson">play-json</a> for JSON serialization support.</li>
  <li>Use of macros to implement service clients, rather than dynamic proxies.</li>
</ul>
<h2><a href="#status" name="status">Status</a></h2>
<p>The following APIs and features are complete:</p>
<ul>
  <li>Service API</li>
  <li>Message broker API with Kafka implementation</li>
  <li>Persistence API with both Cassandra and JDBC implmentations</li>
  <li>Dev mode</li>
  <li>Play integration</li>
</ul>
<p>Meanwhile, the following things are left to be done:</p>
<ul>
  <li>ConductR integration</li>
  <li>Some testkit APIs</li>
  <li>Much of the documentation</li>
</ul>
<p>To create a new Lagom Scala project, using sbt 0.13.13, run:</p>
<pre class="prettyprint"><code>$ sbt new lagom/lagom-scala.g8
</code></pre>
<p>For a reasonably comprehensive demonstration of the Lagom Scala API, you can checkout the <a href="https://github.com/lagom/online-auction-scala">online auction sample app</a>. Note that this is a work in progress, some things aren&rsquo;t complete yet. Of course, the <a href="https://www.lagomframework.com/documentation/1.3.x/scala/Home.html">documentation</a> is also a good place to go.</p>
<p>As this is a milestone release, the API is still considered experimental, and will likely change before the final release. Hence, we recommend not using it for any production services yet.</p>]]></content>
          <dc:date>2016-12-09T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.2.1 is ready!</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-2-1.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>Ignasi Marimon-Clos</name>
            <uri>https://github.com/ignasi35</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-2-1.html</id>
          <updated>2016-12-07T11:00:00.000+11:00</updated>
          <published>2016-12-07T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team is proud to announce the availability of the 1.2.1 version. This release provides several bugfixes and a performance enhancement.</p>
<p>It&rsquo;s been a month since releasing 1.2.0 and the <a href="https://github.com/lagom/lagom/issues">mailing list</a> and Lagom&rsquo;s <a href="https://gitter.im/lagom/lagom">Gitter channel</a> have been <em>on fire</em>. Many are already developing their microservice-based solutions using Lagom, but Lagom is not (yet) free of bugs and the community has been great at helping spot some of these bugs both on documentation or the code itself. This release addresses <a href="https://github.com/lagom/lagom/milestone/5?closed=1">some of these issues</a> improving documentation and performance, and fixing a regression introduced when releasing 1.2.0. Don&rsquo;t forget to use Lagom&rsquo;s <a href="https://github.com/lagom/lagom/issues">issue tracker</a> to report and contribute to fixing issues.</p>
<p>Thanks to all of you that reported and contributed on making this release possible.</p>
<hr/>
<p>Lagom 1.3 is almost here with a ton of <a href="https://github.com/lagom/lagom/milestone/4">new features</a>, so continue <a href="https://www.lagomframework.com/get-involved.html">shaping</a> the future of Lagom.</p>]]></content>
          <dc:date>2016-12-07T11:00:00.000+11:00</dc:date>
        </entry><entry>
          <title>Lagom 1.2 is released!</title>
          <link rel="alternate" href="https://www.lagomframework.com/blog/lagom-1-2.html"/>
          <category term="news" scheme="https://www.lagomframework.com/blog/tags/news.html"/>
          <author>
            <name>Tim Moore</name>
            <uri>https://github.com/TimMoore</uri>
          </author>
          <id>https://www.lagomframework.com/blog/lagom-1-2.html</id>
          <updated>2016-11-08T11:00:00.000+11:00</updated>
          <published>2016-11-08T11:00:00.000+11:00</published>
          <content type="html"><![CDATA[<p>The Lagom team is proud to announce the release of Lagom 1.2! This release introduces support for message brokers, JDBC, and an overhaul of read sides.</p>
<p>If you&rsquo;ve been following along with the RCs, there have only been minor changes since RC2, but if you&rsquo;re upgrading from 1.1.0 or earlier, please be sure to follow the <a href="https://www.lagomframework.com/documentation/1.2.x/java/Migration12.html">migration guide</a>, as there are some changes you&rsquo;ll need to make to your project.</p>
<p>Here&rsquo;s a recap of the major new features that were announced with the release candidates. You can see more details in the <a href="https://www.lagomframework.com/changelog.html">change log</a> or on <a href="https://github.com/lagom/lagom/issues?utf8=%E2%9C%93&q=milestone%3A1.2.0">GitHub</a>.</p>
<hr/>
<h2><a href="#message-broker-support" name="message-broker-support">Message broker support</a></h2>
<p>The biggest feature of Lagom 1.2 is message broker support. This means Lagom now allows both direct streaming of messages between services, as well as streaming of messages through a broker.</p>
<p>Lagom&rsquo;s message broker support does not require any one particular message broker implementation, however out of the box we have only implemented support for Kafka. Kafka is a popular very scalable message broker, and fits well in the Lagom architectural philosophy.</p>
<p>Lagom will automatically run Kafka for you when you run the <code>runAll</code> command, both in Maven and sbt, which makes getting started with a project that uses Kafka very simple. It also abstracts the publishing, partitioning, consuming and failure handling of messaging away from you, so you can focus primarily on your business concerns.</p>
<p>As with Lagom <code>ServiceCall</code>&rsquo;s, which provide a protocol agnostic way of directly communicating with other services that maps down onto HTTP, Lagom provides a new <code>Topic</code> abstraction, which represents a topic that one service publishes, and one or more services consume. Through the use of service descriptors, Lagom allows all the serialization and deserialization logic for these messages to be captured and shared between services.</p>
<p>As a first and primary use case, we have targetted publishing a persistent entity event stream for the source of topics. This allows the implementation of remote read sides, as well as provides a great basis for guaranteed at least once delivery of events between services.</p>
<p>To explore more of Lagom&rsquo;s message broker support, read the <a href="https://www.lagomframework.com/documentation/1.2.x/java/MessageBroker.html">documentation</a>.</p>
<h2><a href="#jdbc-support" name="jdbc-support">JDBC support</a></h2>
<p>Feedback that we got from many potential users was that in order to introduce Lagom into their organisation, it would need to have support for using their existing relational database infrastructure. While a relational database is often not the best choice, particularly for storing event sourced entities, it&rsquo;s not necessarily a bad choice. We felt that having no JDBC support was an unnecessary blocker to organisations getting the benefits of a Lagom based architecture.</p>
<p>Lagom supports JDBC both for <a href="https://www.lagomframework.com/documentation/1.2.x/java/PersistentEntityRDBMS.html">storing persistent entities</a>, as well as for implementing <a href="https://www.lagomframework.com/documentation/1.2.x/java/ReadSideRDBMS.html">read sides</a>.</p>
<h2><a href="#read-side-overhaul" name="read-side-overhaul">Read side overhaul</a></h2>
<p>Lagom&rsquo;s read side support has been overhauled. There are three major parts to this. First of all, read sides that talk to any data store can now be implemented - previously the read side processor API was specific to Cassandra. We still provide a Cassandra specific utility for building Cassandra read sides, as well as a new JDBC specific utility for building JDBC read sides, but these are just helpers for building read sides, you can build a read side in anything. Documentation for the new read side API can be found <a href="https://www.lagomframework.com/documentation/1.2.x/java/ReadSide.html">here</a>.</p>
<p>The second is that read sides can now be sharded, by tagging persistent entity events with sharded tags. Lagom&rsquo;s read side processors now declare a list of tags that they process, rather than just one, and Lagom will automatically distribute the processing of these tags across the cluster. This is great for services with a high throughput of events, or when event processing can be very slow or expensive.</p>
<p>The final feature is that both the Cassandra and JDBC specific read side support utilities provide automatic offset tracking, meaning that your read side processors no longer need to explicitly load and persist offsets. This makes it much simpler to implement a read side processor. Documentation is available for both the <a href="https://www.lagomframework.com/documentation/1.2.x/java/ReadSideCassandra.html">Cassandra read side support</a> and the <a href="https://www.lagomframework.com/documentation/1.2.x/java/ReadSideRDBMS.html">JDBC read side support</a>.</p>
<p>The existing Cassandra read side support is still supported, but is deprecated.</p>
<hr/>
<p>Thanks to everyone who provided feedback on the release candidates. There are more exciting things planned for Lagom 1.3, so please <a href="https://www.lagomframework.com/get-involved.html">Get Involved</a> and help shape the future of Lagom.</p>]]></content>
          <dc:date>2016-11-08T11:00:00.000+11:00</dc:date>
        </entry>
    </feed>