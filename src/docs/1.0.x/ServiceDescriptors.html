<h1 id="Service-Descriptors"><a class="section-marker" href="#Service-Descriptors">ยง</a>Service Descriptors</h1><p>Lagom services are described by an interface, known as a service descriptor. This interface not only defines how the service is invoked and implemented, it also defines the metadata that describes how the interface is mapped down onto an underlying transport protocol. Generally, the service descriptor, its implementation and consumption should remain agnostic to what transport is being used, whether that&rsquo;s REST, websockets, or some other transport. Let&rsquo;s take a look at a simple descriptor:</p>
<pre class="prettyprint"><code class="language-java">import akka.NotUsed;
import com.lightbend.lagom.javadsl.api.*;

import static com.lightbend.lagom.javadsl.api.Service.*;

public interface HelloService extends Service {
    ServiceCall&lt;NotUsed, String, String&gt; sayHello();

    default Descriptor descriptor() {
        return named(&quot;hello&quot;).with(
                call(sayHello())
        );
    }
}</code></pre><p>This descriptor defines a service with one call, the <code>sayHello</code> call. <code>sayHello()</code> is a method that returns something of type <code>ServiceCall</code>, this is a representation of the call that can be invoked when consuming the service, and implemented by the service itself. This is what the interface looks like:</p>
<pre class="prettyprint"><code class="language-java">interface ServiceCall&lt;Id, Request, Response&gt; {
  CompletionStage&lt;Response&gt; invoke(Id id, Request request);
}
</code></pre><p>An important thing to note here is that invoking the <code>sayHello()</code> method does not actually invoke the call, it simply gets a handle to the call, which can then be invoked using the <code>invoke</code> method.</p><p><a href="api/java/index.html?com/lightbend/lagom/javadsl/api/ServiceCall.html"><code>ServiceCall</code></a> takes three type parameters, <code>Id</code>, <code>Request</code> and <code>Response</code>. The <code>Id</code> is extracted from the incoming identifier - usually the path in the case of a REST request - of the call. The example above doesn&rsquo;t have an ID, which means when implemented using the REST transport it&rsquo;s going to use a static path. The <code>Request</code> parameter is the type of the incoming request message, and the <code>Response</code> parameter is the type of the outgoing response message. In the example above, these are both <code>String</code>, so our service call just handles simple text messages.</p><p>While the <code>sayHello()</code> method describes how the call will be programmatically invoked or implemented, it does not describe how this call gets mapped down onto the transport. This is done by providing a <code>default</code> implementation of the <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/Service.html#descriptor--"><code>descriptor()</code></a> call, whose interface is described by <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/Service.html"><code>Service</code></a>.</p><p>You can see that we&rsquo;re returning a service named <code>hello</code>, and we&rsquo;re describing one call, the <code>sayHello</code> call. Because this service is so simple, in this case we don&rsquo;t need to do anything more than simply pass the call to the <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/Service.html#call-com.lightbend.lagom.javadsl.api.ServiceCall-"><code>call</code></a> method. When mapped to a REST transport, Lagom will map <code>sayHello()</code> calls to a <code>POST</code> request on a static path of <code>/sayHello</code>, with <code>text/plain</code> request and response bodies. All of this is configurable, as we&rsquo;ll see below.</p><h2 id="Call-identifiers"><a class="section-marker" href="#Call-identifiers">ยง</a>Call identifiers</h2><p>Each service call needs to have an identifier. An identifier is used to provide routing information to the implementation of the client and the service, so that calls over the wire can be mapped to the appropriate call. Identifiers can be a static name or path, or they can have dynamic components, where a dynamic id is extracted from a path. The dynamic id type is represented in the <code>ServiceCall</code> interface using the <code>Id</code> type parameter, when the call identifier is static, this type parameter will be <code>akka.NotUsed</code>.</p><p>The simplest type of identifier is a name, and by default, that name is set to be the same name as the name of the method on the interface that implements it. A custom name can also be supplied, by passing it to the <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/Service.html#namedCall-java.lang.String-com.lightbend.lagom.javadsl.api.ServiceCall-"><code>namedCall</code></a> method:</p>
<pre class="prettyprint"><code class="language-java">default Descriptor descriptor() {
    return named(&quot;hello&quot;).with(
            namedCall(&quot;hello&quot;, sayHello())
    );
}</code></pre><p>In this case, we&rsquo;ve named it <code>hello</code>, instead of the default of <code>sayHello</code>. When implemented using REST, this will mean this call will have a path of <code>/hello</code>.</p><h3 id="Path-based-identifiers"><a class="section-marker" href="#Path-based-identifiers">ยง</a>Path based identifiers</h3><p>The second type of identifier is a path based identifier. This uses a URI path and query string to route calls, and from it a dynamic identifier can optionally be extracted out. They can be configured using the <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/Service.html#pathCall-java.lang.String-com.lightbend.lagom.javadsl.api.ServiceCall-"><code>pathCall</code></a> method.</p><p>Dynamic ids are extracted from the path using an <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/deser/IdSerializer.html"><code>IdSerializer</code></a>. Lagom provides many id serializers out of the box, these can be found in <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/deser/IdSerializers.html"><code>IdSerializers</code></a>, and if your <code>Id</code> type is one of those, Lagom will be able to automatically use that. For example, here&rsquo;s an example call that uses a <code>Long</code> id:</p>
<pre class="prettyprint"><code class="language-java">ServiceCall&lt;Long, NotUsed, Order&gt; getOrder();

default Descriptor descriptor() {
    return named(&quot;orders&quot;).with(
            pathCall(&quot;/order/:id&quot;, getOrder())
    );
}</code></pre><p>When your id is more complex, such as when it has multiple path components, you will need to define a custom type to represent it. Lagom id types should be very simple immutable objects. Lagom provides some helpers for creating serializers for id types, the most useful being the <code>create</code> methods. These helpers are designed to take a method reference, such as the constructor of the type, and then a lambda to extract the same parameters back out into a list. The custom id serializer can then be passed to the <code>with</code> method on the service call. For example, here&rsquo;s an <code>ItemId</code>, that contains both an <code>orderId</code> property and an <code>id</code> property:</p>
<pre class="prettyprint"><code class="language-java">import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.lightbend.lagom.javadsl.immutable.ImmutableStyle;
import org.immutables.value.Value;

@Value.Immutable
@ImmutableStyle
@JsonDeserialize(as = ItemId.class)
@JsonSerialize(as = ItemId.class)
public interface AbstractItemId {
    @Value.Parameter
    long orderId();
    @Value.Parameter
    long itemId();
}</code></pre><p>Note that we&rsquo;re using the <a href="Immutable.html#Immutables">Immutables</a> library here, so this will generate an immutable <code>ItemId</code> class. We&rsquo;re also using the <code>@Value.Parameter</code> annotation to tell it to generate a static constructor method called <code>of</code>. Now, using that static constructor method, we can create an id serializer:</p>
<pre class="prettyprint"><code class="language-java">ServiceCall&lt;ItemId, NotUsed, Item&gt; getItem();

default Descriptor descriptor() {
    return named(&quot;orders&quot;).with(
            pathCall(&quot;/order/:orderId/item/:itemId&quot;, getItem())
                    .with(IdSerializers.create(&quot;ItemId&quot;, ItemId::of,
                            id -&gt; Arrays.asList(id.orderId(), id.itemId())))
    );
}</code></pre><p>You may have many routes that use the same id, in which case, you can configure the custom id serializer at the service level, like so:</p>
<pre class="prettyprint"><code class="language-java">ServiceCall&lt;ItemId, NotUsed, Item&gt; getItem();
ServiceCall&lt;ItemId, NotUsed, ItemHistory&gt; getItemHistory();

default Descriptor descriptor() {
    return named(&quot;orders&quot;).with(
            pathCall(&quot;/order/:orderId/item/:itemId&quot;, getItem()),
            pathCall(&quot;/order/:orderId/item/:itemId/history&quot;, getItemHistory())
    ).with(ItemId.class, IdSerializers.create(&quot;ItemId&quot;, ItemId::of,
            id -&gt; Arrays.asList(id.orderId(), id.itemId())));
}</code></pre><p>Id serializers can also work with types produced by other id serializers, for example, let&rsquo;s say you had the following <code>OrderId</code> class:</p>
<pre class="prettyprint"><code class="language-java">@Value.Immutable
@ImmutableStyle
public interface AbstractOrderId {
    @Value.Parameter
    long id();
}</code></pre><p>And then an <code>ItemId</code> class that used it:</p>
<pre class="prettyprint"><code class="language-java">@Value.Immutable
@ImmutableStyle
public interface AbstractItemId {
    @Value.Parameter
    OrderId orderId();
    @Value.Parameter
    long itemId();
}</code></pre><p>Then if you define id serializers for those at the service level, Lagom will wire them together for you:</p>
<pre class="prettyprint"><code class="language-java">ServiceCall&lt;OrderId, NotUsed, Order&gt; getOrder();
ServiceCall&lt;ItemId, NotUsed, Item&gt; getItem();
ServiceCall&lt;ItemId, NotUsed, ItemHistory&gt; getItemHistory();

default Descriptor descriptor() {
    return named(&quot;orders&quot;).with(

            pathCall(&quot;/order/:orderId&quot;, getOrder()),
            pathCall(&quot;/order/:orderId/item/:itemId&quot;, getItem()),
            pathCall(&quot;/order/:orderId/item/:itemId/history&quot;, getItemHistory())

    ).with(ItemId.class, IdSerializers.create(&quot;ItemId&quot;, ItemId::of,
            id -&gt; Arrays.asList(id.orderId(), id.itemId()))
    ).with(OrderId.class, IdSerializers.create(&quot;OrderId&quot;, OrderId::of,
            OrderId::id));
}</code></pre><h3 id="REST-identifiers"><a class="section-marker" href="#REST-identifiers">ยง</a>REST identifiers</h3><p>The final type of identifier is a REST identifier. REST identifiers are designed to be used when creating semantic REST APIs. They use both a path, as with the path based identifier, and a request method, to identify them. They can be configured using the <a href="api/java/index.html?com/lightbend/lagom/javadsl/api/Service.html#restCall-com.lightbend.lagom.javadsl.api.transport.Method-java.lang.String-com.lightbend.lagom.javadsl.api.ServiceCall-"><code>restCall</code></a> method:</p>
<pre class="prettyprint"><code class="language-java">ServiceCall&lt;OrderId, Item, NotUsed&gt; addItem();
ServiceCall&lt;ItemId, NotUsed, Item&gt; getItem();
ServiceCall&lt;ItemId, NotUsed, NotUsed&gt; deleteItem();

default Descriptor descriptor() {
    return named(&quot;orders&quot;).with(

            restCall(Method.POST,   &quot;/order/:orderId/item&quot;,         addItem()),
            restCall(Method.GET,    &quot;/order/:orderId/item/:itemId&quot;, getItem()),
            restCall(Method.DELETE, &quot;/order/:orderId/item/:itemId&quot;, deleteItem())

    ).with(ItemId.class, IdSerializers.create(&quot;ItemId&quot;, ItemId::of,
            id -&gt; Arrays.asList(id.orderId(), id.itemId()))
    ).with(OrderId.class, IdSerializers.create(&quot;OrderId&quot;, OrderId::of,
            OrderId::id));
}</code></pre><h2 id="Messages"><a class="section-marker" href="#Messages">ยง</a>Messages</h2><p>Every service call in Lagom has a request message type and a response message type. Like ids, when these are not used, the <code>akka.NotUsed</code> can be used in their place. Request and response message types fall into two categories, strict and streamed.</p><h3 id="Strict-messages"><a class="section-marker" href="#Strict-messages">ยง</a>Strict messages</h3><p>A strict message is a single message that can be represented by a simple Java object. The message will be buffered into memory, and then parsed, for example, as json. When both message types are strict, the call is said to be a synchronous call, that is, a request is sent and received, then a response is sent and received. The caller and callee have synchronized in their communication.</p><p>So far, all of the service call examples we&rsquo;ve seen have used strict messages, for example, the order service descriptors above accept and return items and orders. The input value is passed directly to the service call, and returned directly from the service call, and these values are serialized to a JSON buffer in memory before being sent, and read entirely into memory before being deserialized back from JSON.</p><h3 id="Streamed-messages"><a class="section-marker" href="#Streamed-messages">ยง</a>Streamed messages</h3><p>A streamed message is a message of type <a href="http://doc.akka.io/japi/akka/2.4.4/akka/stream/javadsl/Source.html"><code>Source</code></a>. <code>Source</code> is an <a href="http://doc.akka.io/docs/akka/2.4.4/java.html">Akka streams</a> API that allows asynchronous streaming and handling of messages. Here&rsquo;s an example streamed service call:</p>
<pre class="prettyprint"><code class="language-java">ServiceCall&lt;Integer, String, Source&lt;String, ?&gt;&gt; tick();

default Descriptor descriptor() {
    return named(&quot;clock&quot;).with(
        pathCall(&quot;/tick/:interval&quot;, tick())
    );
}</code></pre><p>This service call has a strict request type and a streamed response type. An implementation of this might return a <code>Source</code> that sends the input tick message <code>String</code> at the specified interval.</p><p>A bidirectional streamed call might look like this:</p>
<pre class="prettyprint"><code class="language-java">ServiceCall&lt;NotUsed, Source&lt;String, ?&gt;, Source&lt;String, ?&gt;&gt; sayHello();

default Descriptor descriptor() {
    return named(&quot;hello&quot;).with(
        call(sayHello())
    );
}</code></pre><p>In this case, the server might return a <code>Source</code> that converts every message received in the request stream to messages prefixed with <code>Hello</code>.</p><p>Lagom will choose an appropriate transport for the stream, typically, this will be WebSockets. WebSockets support bidirectional streaming, and so are a good general purpose option for streaming. When only one of the request or response message is streamed, Lagom will implement the sending and receiving of the strict message by sending or receiving a single message, and then leaving the WebSocket open until the other direction closes. Otherwise, Lagom will close the WebSocket when either direction closes.</p><h3 id="Message-serialization"><a class="section-marker" href="#Message-serialization">ยง</a>Message serialization</h3><p>By default, Lagom will choose an appropriate serializer for request and response serialization and deserialization. Out of the box, Lagom will use JSON for communication, using Jackson to serialize and deserialize messages.</p><p>For details on message serializers, including how to write and configure custom message serializers, see <a href="MessageSerializers.html">Message Serializers</a>.</p>